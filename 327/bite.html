<p>In <a href="../../../312" target="_blank" rel="noopener">Bite 312</a> we learned how to identify builtin functions, modules, and keywords when provided with a list of strings.</p>
<p>In this Bite we take it a step further considering the following scenario: <em>What if somebody gives you some python source code and asks you to identify which modules it uses and determine how frequently functions from those modules are used?</em></p>
<p>For a few small files you can solve this problem manually using python's regex facility or with command line tools like <a href="https://www.gnu.org/software/grep/manual/grep.html" target="_blank" rel="noopener"><code>grep</code></a> or <a href="https://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener"><code>awk</code></a>. However the problem becomes more difficult to manage when you consider a library which may have many large modules.</p>
<p>The <a href="https://docs.python.org/3.9/library/ast.html" target="_blank" rel="noopener"><code>ast</code> module</a> can help you in this scenario.</p>
<h4>Intro to the <code>ast</code> module</h4>
<p>The <code>ast</code> module transforms any python source code into a tree representation of the underlying python grammar. Such tree is called <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">Abstract Syntax Tree (AST)</a>, and it is a data structure used to reason about programming languages grammar in general.</p>
<p>Let's see the <code>ast</code> module in action on a simple example:</p>
<pre>&gt;&gt;&gt; import ast<br />&gt;&gt;&gt; tree = ast.parse("one_plus_two = 1+2")<br />&gt;&gt;&gt; ast.dump(tree)<br />"Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=BinOp(left=Num(n=1), op=Add(), right=Num(n=2)))])"</pre>
<p>...ghhh, pretty condensed output, isn't it? Let's rearrange it manually to make it more readable:</p>
<pre>"Module(<br />&nbsp; &nbsp; body=[<br />&nbsp; &nbsp; &nbsp; &nbsp; Assign(<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targets=[<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name(id='one_plus_two', ctx=Store())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value=BinOp(<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left=Num(n=1),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op=Add(),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right=Num(n=2))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )<br />&nbsp; &nbsp; ]<br />)"<br />Module<br />&nbsp; &nbsp;|____ Assign<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |___ Name<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |___ BinOp<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|__ Num<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|__ Add<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|__ Num</pre>
<p>What can we observe?</p>
<p>- The outer most node <code>Module</code> is the root of our tree.</p>
<p>- The <code>Module.body</code> attribute is a list of nodes, one for each instruction of the input program. Our example program consists of one assignment instruction, so <code>Module.body</code> contains only one <code>Assign</code> node.</p>
<p>- The <code>Assign</code> node has two attributes, <code>Assign.targets</code> and <code>Assign.value</code>, which describe the left and right-hand sides of the assignment with respect to the equal sign.</p>
<p>&nbsp; &nbsp; - The <code>Assign.targets</code> attribute is a list containing the different destinations of the assignment operation. In our case only the node <code>Name</code> is in the list since the assignment target is a single variable. Notice also that the <code>Name.id</code> attribute of the target node contains the name of the variable <code>"one_plus_two"</code> as indeed specified in the source code.</p>
<p>&nbsp; &nbsp; - The <code>Assign.value</code> contains a <code>BinOp</code> node since the right hand side of the assignment is a binary operation between two operands. The attributes <code>BinOp.left</code>&nbsp;and <code>BinOp.right</code> specify the left and right operands for the <code>BinOp.op</code> operation. Remember, the expression on the right hand side of the assignment was <code>1 + 2</code>, so it is not surprising that <code>BinOp.left</code> and <code>BinOp.right</code> nodes are <code>Num</code>&nbsp;nodes with values <code>1</code> and <code>2</code> respectively.</p>
<p>The <code>ast</code> module provides a large variety of nodes to cover the different aspects of the Python grammar (for more details, see <a href="https://docs.python.org/3/library/ast.html?highlight=ast#module-ast" target="_blank" rel="noopener">the official python 3.9 doc of the <code>ast</code>&nbsp;module</a>, as well as the external documentation <a href="https://greentreesnakes.readthedocs.io/" target="_blank" rel="noopener">Green Tree Snake</a> as suggested by the official doc).</p>
<p>Overall, the rich functionality of the <code>ast</code>&nbsp;module makes it easy to work with an AST data structure to both inspect and manipulate python source code programmatically.</p>
<p>As a concrete example, <a href="https://pypi.org/project/MutPy/" target="_blank" rel="noopener"><code>mutpy</code></a>, which we also introduced in <a href="../../../../../bites/244/" target="_blank" rel="noopener">Bite 244</a>, is a mutation testing tool that artificially alters the code under testing to broaden the unit tests in an automated fashion. Under the hood, it uses the <code>ast</code> module to (i) create an AST, (ii) apply mutations, and (iii) convert the tree into a code object via the <a href="https://docs.python.org/3/library/functions.html#compile" target="_blank" rel="noopener">builtin function <code>compile()</code></a> before executing it (see <code><a href="https://github.com/mutpy/mutpy/blob/5c8b3ca0d365083a4da8333f7fce8783114371fa/mutpy/utils.py#L27" target="_blank" rel="noopener">mutpy.mutpy.utils.create_module()</a></code>&nbsp;for details).</p>
<h4>Our objective</h4>
<p>In this bite we are going to see how the <code>ast</code> module makes it easy to visit an AST tree, and discover <code>import</code> and <code>from ... import</code> statements, and function calls. Specifically, we will work with <code><a href="https://docs.python.org/3/library/ast.html?highlight=ast#ast.Import" target="_blank" rel="noopener">ast.Import</a></code>, <code><a href="https://docs.python.org/3/library/ast.html?highlight=ast#ast.ImportFrom" target="_blank" rel="noopener">ast.ImportFrom</a></code>, and <code><a href="https://docs.python.org/3/library/ast.html?highlight=ast#ast.Call" target="_blank" rel="noopener">ast.Call</a></code> node types.</p>
<p>Given a python program source code, determine the following:</p>
<p>- Which builtin functions are used.</p>
<p>- Which modules are imported.</p>
<p>- Which calls make direct use of imported modules or submodules.</p>
<p>To do so, we are going to use the <code>ast</code> module. Specifically, we take advantage of the <a href="https://docs.python.org/3/library/ast.html?highlight=ast#ast.NodeVisitor" target="_blank" rel="noopener">NodeVisitor class</a> to create our own <code>AstVisitor</code> class to visit the nodes of an AST.</p>
<p>We already provide you a template of the <code>AstVisitor</code> class with a <code>.parse()</code> method to create an AST tree and trigger a visit, and we registered three callbacks that are invoked when three specific node types are encountered during parsing:</p>
<p>- <code>.visit_Import()</code>&nbsp;called when visiting a node related to <code>import xyz</code>&nbsp;statements (see the <code><a href="https://docs.python.org/3/library/ast.html?highlight=ast#ast.Import" target="_blank" rel="noopener">ast.Import</a></code> node documentation).</p>
<p>- <code>.visit_ImportFrom()</code> called when visiting a node related to <code>from abc import xyz</code>&nbsp;statements (see the <a href="https://docs.python.org/3/library/ast.html?highlight=ast#ast.ImportFrom" target="_blank" rel="noopener"><code>ast.ImportFrom</code></a> node documentation).</p>
<p>- <code>.visit_Call()</code> called during when visiting a node related to function call (see the <code><a href="https://docs.python.org/3/library/ast.html?highlight=ast#ast.Call" target="_blank" rel="noopener">ast.Call</a></code> node documentation).</p>
<p>What is left to do is to complete the implementation of the three methods mentioned so to "track" both which builtins functions (if any) are used, which modules are imported (if any) and which calls they related to (if any). To be more specific, we want to know both the list of builtins / methods, but also the line number where each of tracked objects are located (see the <a href="https://docs.python.org/3.9/library/ast.html?highlight=ast#ast.AST" target="_blank" rel="noopener"><code>ast.AST</code></a> documentation). To report on the tracking you need to complete the following methods defined in the template:</p>
<p>- <code>.builtins()</code> returns a list of string, one for each builtin functions tracked.</p>
<p>- <code>.builtins_lineno()</code> returns a dictionary whose keys are builtins functions, and values are the line number where the related call occurred.</p>
<p>- <code>.modules()</code> returns a list of string, one for each imported module.</p>
<p>- <code>.modules_lineno()</code>&nbsp;returns a dictionary whose keys are module object calls, and values are the line number where the related call occurred.</p>
<p>The tracking you need to implement is subject to the following rules:</p>
<p>- __rule-1__: each of the methods support an optional input parameter named <code>valid</code> to specify a list of builtins or modules to restrict the search to. When <code>valid=None</code>, all builtins and modules will be reported in the output.</p>
<p>- __rule-2__: resolve aliased import statements and report their true names.</p>
<p>- __rule-3__: resolve submodule imports and express the module path using dotted notation.</p>
<p>- __rule-4__: when considering modules, <code>valid=</code> can contain alias names, but they need to be expanded to full names to comply with __rule-2__;</p>
<h4>An example</h4>
<pre>&gt;&gt; code = '''<br />import pandas as pd<br />import numpy as np<br />from argparse import ArgumentParser<br />print("this is a test")<br />parser = ArgumentParser()<br />len("12345")<br />df_tmp = pd.DataFrame(range(10), column=["x"])<br />df_tmp.loc[:, "y"] = df_tmp[x] + 1<br />np.random.random()<br />'''<br /><br />&gt;&gt; vst = AstVisitor(code)<br />&gt;&gt; vst.builtins()<br />["print", "range", "len"]<br />&gt;&gt; vst.modules()<br />["argparse", "numpy", "pandas"]<br />&gt;&gt; vst.builtins_lineno()<br />{"print": [6], "len": [9], "range": [11]}<br />&gt;&gt; vst.modules_lineno()<br />{"argparse.ArgumentParser": [8], "pandas.DataFrame": [11], "numpy.random.random": [14]}</pre>
<p>Considering the output of <code>vst.modules_lineno()</code>, notice the following:</p>
<p>- The call <code>ArgumentParser()</code> is resolved into <code>argparse.ArgumentParser</code>&nbsp;to comply with __rule-3__.</p>
<p>- The <code>pd.DataFrame()</code> and <code>np.random.random()</code> calls are resolved into <code>pandas.DataFrame</code> and <code>numpy.random.random</code>&nbsp;respectively to comply with __rule-2__.</p>
<p>Let's see a few more examples using the code from the previous example, but this time using <code>valid=</code> to constrain the search output:</p>
<pre>&gt;&gt; first = vst.builtins(valid=["iter"])<br />&gt;&gt; first<br />[]<br />&gt;&gt; second = vst.builtins_lineno(valid=["iter"])<br />&gt;&gt; second<br />{}<br />&gt;&gt; third = vst.builtins_lineno(valid=["iter", "range"])<br />&gt;&gt; third<br />{"range": [11]}<br />&gt;&gt; fourth = vst.modules(valid=["np"])<br />&gt;&gt; fourth<br />["numpy"]<br />&gt;&gt; fifth = vst.modules(valid=["numpy"])<br />&gt;&gt; fifth<br />["numpy"]<br />&gt;&gt; sixth = vst.modules_lineno(valid=["numpy"])<br />&gt;&gt; sixth<br />{"numpy.random.random": [14]}</pre>
<p>Notice the following:</p>
<p>- <code>first</code> and <code>second</code> are empty since <code>iter</code> is not used in the source code.</p>
<p>- <code>third</code> contains only <code>range</code> since <code>iter</code> is not used in the source code.</p>
<p>- <code>fourth</code> contains <code>numpy</code> even if we specified <code>valid=["np"]</code>&nbsp;to comply with __rule-2__ and __rule-4__.</p>
<p>- <code>fifth</code> is identical to <code>fourth</code> as expected, but notice that this time we specified <code>valid=["numpy"]</code> while before we used <code>valid=["np"]</code>.</p>
<p>- <code>sixth</code> contains only calls related to <code>numpy</code> as requested, but notice how we specified <code>valid=["numpy"]</code> while the original code has the statement <code>np.random.random()</code>, hence the search takes care of aliasing to comply with __rule-2__.</p>
<h4>Final notes:</h4>
<p>- Please refer to the <a href="https://docs.python.org/3.9/library/ast.html?highlight=ast#module-ast" target="_blank" rel="noopener">python3.9 documentation</a> or, as suggested by the doc itself, the external <a href="https://greentreesnakes.readthedocs.io/" target="_blank" rel="noopener">Green Tree Snake</a> documentation. The official documentation for python version lower than 3.9 is not very complete. If you are coding outside the pybites platform, you should not have issues in solving this bite with any python versions higher than 3.6.</p>
<p>- Tracking name aliasing is the most complex part to implement successfully and depends on you understanding what the various node attributes mean.</p>
<p>- Beware of expressions like <code>module.submodule.submodule.func()</code> which may be present when handling <code>Call</code>&nbsp;nodes.</p>
<p>- Lastly, I recommend you spend some time with the python console trying to parse simple statements and investigate the AST tree manually. The <a href="https://ipython.org" target="_blank" rel="noopener"><code>ipython</code> console</a> console is great for this sort of exploration.</p>
<p>Good luck!</p>